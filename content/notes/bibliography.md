+++
title = "Bibliography"
author = ["Ben Mezger"]
date = 2020-11-21T00:04:00+01:00
slug = "bibliography"
tags = ["research", "bibliography"]
type = "notes"
draft = false
bookCollapseSection = true
+++

Some of these bibliographies I've been reading for my research and some I find it
interesting to keep around my library.


## Operating Systems {#operating-systems}


### Introductory {#introductory}


#### Modern Operating Systems {#modern-operating-systems}

{{% details "Bibtex" %}}

```bibtex
@book{tanenbaum2014ModenOS,
  author          = {Tanenbaum, Andrew S. and Bos, Herbert},
  title           = {Modern Operating Systems},
  year            = 2014,
  isbn            = {013359162X},
  publisher       = {Prentice Hall Press},
  address         = {USA},
  edition         = {4th},
  abstract        = { Modern Operating Systems, Fourth Edition, is intended for
                  introductory courses in Operating Systems in Computer Science,
                  Computer Engineering, and Electrical Engineering programs. It
                  also serves as a useful reference for OS professionals The
                  widely anticipated revision of this worldwide best-seller
                  incorporates the latest developments in operating systems (OS)
                  technologies. The Fourth Edition includes up-to-date materials
                  on relevantOS. Tanenbaum also provides information on current
                  research based on his experience as an operating systems
                  researcher. Modern Operating Systems, Third Editionwas the
                  recipient of the 2010 McGuffey Longevity Award. The McGuffey
                  Longevity Award recognizes textbooks whose excellence has been
                  demonstrated over time.http://taaonline.net/index.html
                  Teaching and Learning Experience This program will provide a
                  better teaching and learning experiencefor you and your
                  students. It will help: Provide Practical Detail on the Big
                  Picture Concepts: A clear and entertaining writing style
                  outlines the concepts every OS designer needs to master. Keep
                  Your Course Current: This edition includes information on the
                  latest OS technologies and developments Enhance Learning with
                  Student and Instructor Resources: Students will gain hands-on
                  experience using the simulation exercises and lab experiments.
                  }
}
```

{{% /details %}}


#### Operating Systems: Internals and Design Principle {#operating-systems-internals-and-design-principle}

{{% details "Bibtex" %}}

```bibtex
@book{stallings2018OperatingSysInternalAndDesign,
  author          = {Stallings, William},
  title           = {Operating Systems: Internals and Design Principles, 9/e},
  year            = 2018,
  isbn            = 9352866711,
  publisher       = {Pearson IT Certification},
  address         = {Indianapolis, Indiana, USA},
  edition         = {9th},
  abstract        = {Please Read Notes: Brand New, International Softcover
                  Edition, Printed in black and white pages, minor self wear on
                  the cover or pages, Sale restriction may be printed on the
                  book, but Book name, contents, and author are exactly same as
                  Hardcover Edition. Fast delivery through DHL/FedEx express.}
}
```

{{% /details %}}


#### Operating Systems Design and Implementation (3rd Edition) {#operating-systems-design-and-implementation--3rd-edition}

{{% details "Bibtex" %}}

```bibtex
@book{tanenbaum2005OperatingSysImplementation,
  author          = {Tanenbaum, Andrew S and Woodhull, Albert S},
  title           = {Operating Systems Design and Implementation (3rd Edition)},
  year            = 2005,
  isbn            = 0131429388,
  publisher       = {Prentice-Hall, Inc.},
  address         = {USA}
}
```

{{% /details %}}


### RTOS {#rtos}


#### Operating Systems for Low-End Devices in the Internet of Things: A Survey {#operating-systems-for-low-end-devices-in-the-internet-of-things-a-survey}

{{% details "Bibtex" %}}

```bibtex
@article{Hahm2015OSForLowEndDevice,
  author          = {O. {Hahm} and E. {Baccelli} and H. {Petersen} and N.
                  {Tsiftes}},
  journal         = {IEEE Internet of Things Journal},
  title           = {Operating Systems for Low-End Devices in the Internet of
                  Things: A Survey},
  year            = 2016,
  volume          = 3,
  number          = 5,
  pages           = {720-734},
  abstract        = {The Internet of Things (IoT) is projected to soon
                  interconnect tens of billions of new devices, in large part
                  also connected to the Internet. IoT devices include both
                  high-end devices which can use traditional go-to operating
                  systems (OSs) such as Linux, and low-end devices which cannot,
                  due to stringent resource constraints, e.g., very limited
                  memory, computational power, and power supply. However,
                  large-scale IoT software development, deployment, and
                  maintenance requires an appropriate OS to build upon. In this
                  paper, we thus analyze in detail the specific requirements
                  that an OS should satisfy to run on low-end IoT devices, and
                  we survey applicable OSs, focusing on candidates that could
                  become an equivalent of Linux for such devices, i.e., a
                  one-size-fits-most, open source OS for low-end IoT devices.},
  keywords        = {Internet of Things;mobile computing;operating systems
                  (computers);software maintenance;software maintenance;software
                  deployment;software development;IoT;Internet of Things;low-end
                  device;OS;operating system;Random access
                  memory;Hardware;Internet of things;Operating
                  systems;Standards;Embedded software;Internet of Things
                  (IoT);low-power electronics;operating system (OS)},
  doi             = {10.1109/JIOT.2015.2505901},
  ISSN            = {2327-4662},
  month           = {Oct},
}
```

{{% /details %}}


### Synchronization {#synchronization}


#### Little book of semaphores {#little-book-of-semaphores}

{{% details "Bibtex" %}}

```bibtex
@book{LittleBookOfSemaphores,
  title           = {The little book of semaphores},
  author          = {Downey, Allen},
  volume          = 2,
  number          = 2,
  year            = 2008,
  publisher       = {Green Tea Press},
  url             = "https://github.com/AllenDowney/LittleBookOfSemaphores",
}
```

{{% /details %}}


## Computer Architecture {#computer-architecture}


### Network-On-Chip (NoC) {#network-on-chip--noc}


#### Redes-em-Chip: arquiteturas e modelos para avaliação de área e desempenho {#redes-em-chip-arquiteturas-e-modelos-para-avaliação-de-área-e-desempenho}

{{% details "Bibtex" %}}

```bibtex
@phdthesis{RedesEmChipArquiteturasEmodelosParaAvaliacaoDeAreaEdesempenho,
  author          = {Cesar Albenes Zeferino},
  title           = {Redes-em-Chip: arquiteturas e modelos para avaliação de
                  área e desempenho},
  year            = 2003,
  school          = {Universidade Federal do Rio Grande do Sul},
  address         = {Porto Alegre, RS, Brasil},
  abstract        = {Com o advento dos processos submicrônicos, a capacidade de
                  integração de transistores tem atingido níveis que
                  possibilitam a construção de um sistema completo em uma única
                  pastilha de silício. Esses sistemas, denominados sistemas
                  integrados, baseiam-se no reuso de blocos previamente
                  projetados e verificados, os quais são chamados de núcleos ou
                  blocos de propriedade intelectual. Os sistemas integrados
                  atuais incluem algumas poucas dezenas de núcleos, os quais são
                  interconectados por meio de arquiteturas de comunicação
                  baseadas em estruturas dedicadas de canais ponto-a-ponto ou em
                  estruturas reutilizáveis constituídas por canais multiponto,
                  denominadas barramentos. Os futuros sistemas integrados irão
                  incluir de dezenas a centenas de núcleos em um mesmo chip com
                  até alguns bilhões de transistores, sendo que, para atender às
                  pressões do mercado e amortizar os custos de projeto entre
                  vários sistemas, é importante que todos os seus componentes
                  sejam reutilizáveis, incluindo a arquitetura de comunicação.
                  Das arquiteturas utilizadas atualmente, o barramento é a única
                  que oferece reusabilidade. Porém, o seu desempenho em
                  comunicação e o seu consumo de energia degradam com o
                  crescimento do sistema. Para atender aos requisitos dos
                  futuros sistemas integrados, uma nova alternativa de
                  arquitetura de comunicação tem sido proposta na comunidade
                  acadêmica. Essa arquitetura, denominada rede-em-chip,
                  baseia-se nos conceitos utilizados nas redes de interconexão
                  para computadores paralelos. Esta tese se situa nesse contexto
                  e apresenta uma arquitetura de rede-em-chip e um conjunto de
                  modelos para a avaliação de área e desempenho de arquiteturas
                  de comunicação para sistemas integrados. A arquitetura
                  apresentada é denominada SoCIN (System-on-Chip Interconnection
                  Network) e apresenta como diferencial o fato de poder ser
                  dimensionada de modo a atender a requisitos de custo e
                  desempenho da aplicação alvo. Os modelos desenvolvidos
                  permitem a estimativa em alto nível da área em silício e do
                  desempenho de arquiteturas de comunicação do tipo barramento e
                  rede-em-chip. São apresentados resultados que demonstram a
                  efetividade das redes-em-chip e indicam as condições que
                  definem a aplicabilidade das mesmas.},
}
```

{{% /details %}}


#### Principles and Practices of Interconnection Network {#principles-and-practices-of-interconnection-network}

{{% details "Bibtex" %}}

```bibtex
@book{principelsAndPracticesOfInterconnectionNetworks,
  author          = {Dally, William James and Towles, Brian Patrick},
  title           = {Principles and Practices of Interconnection Networks},
  year            = 2004,
  isbn            = 9780080497808,
  publisher       = {Morgan Kaufmann Publishers Inc.},
  address         = {San Francisco, CA, USA},
  abstract        = {One of the greatest challenges faced by designers of
                  digital systems is optimizing the communication and
                  interconnection between system components. Interconnection
                  networks offer an attractive and economical solution to this
                  communication crisis and are fast becoming pervasive in
                  digital systems. Current trends suggest that this
                  communication bottleneck will be even more problematic when
                  designing future generations of machines. Consequently, the
                  anatomy of an interconnection network router and science of
                  interconnection network design will only grow in importance in
                  the coming years. This book offers a detailed and
                  comprehensive presentation of the basic principles of
                  interconnection network design, clearly illustrating them with
                  numerous examples, chapter exercises, and case studies. It
                  incorporates hardware-level descriptions of concepts, allowing
                  a designer to see all the steps of the process from abstract
                  design to concrete implementation. ·Case studies throughout
                  the book draw on extensive author experience in designing
                  interconnection networks over a period of more than twenty
                  years, providing real world examples of what works, and what
                  doesn't. ·Tightly couples concepts with implementation costs
                  to facilitate a deeper understanding of the tradeoffs in the
                  design of a practical network. ·A set of examples and
                  exercises in every chapter help the reader to fully understand
                  all the implications of every design decision. Table of
                  Contents Chapter 1 Introduction to Interconnection Networks
                  1.1 Three Questions About Interconnection Networks 1.2 Uses of
                  Interconnection Networks 1.3 Network Basics 1.4 History 1.5
                  Organization of this Book Chapter 2 A Simple Interconnection
                  Network 2.1 Network Specifications and Constraints 2.2
                  Topology 2.3 Routing 2.4 Flow Control 2.5 Router Design 2.6
                  Performance Analysis 2.7 Exercises Chapter 3 Topology Basics
                  3.1 Nomenclature 3.2 Traffic Patterns 3.3 Performance 3.4
                  Packaging Cost 3.5 Case Study: The SGI Origin 2000 3.6
                  Bibliographic Notes 3.7 Exercises Chapter 4 Butterfly Networks
                  4.1 The Structure of Butterfly Networks 4.2 Isomorphic
                  Butterflies 4.3 Performance and Packaging Cost 4.4 Path
                  Diversity and Extra Stages 4.5 Case Study: The BBN Butterfly
                  4.6 Bibliographic Notes 4.7 Exercises Chapter 5 Torus Networks
                  5.1 The Structure of Torus Networks 5.2 Performance 5.3
                  Building Mesh and Torus Networks 5.4 Express Cubes 5.5 Case
                  Study: The MIT J-Machine 5.6 Bibliographic Notes 5.7 Exercises
                  Chapter 6 Non-Blocking Networks 6.1 Non-Blocking vs.
                  Non-Interfering Networks 6.2 Crossbar Networks 6.3 Clos
                  Networks 6.4 Benes Networks 6.5 Sorting Networks 6.6 Case
                  Study: The Velio VC2002 (Zeus) Grooming Switch 6.7
                  Bibliographic Notes 6.8 Exercises Chapter 7 Slicing and Dicing
                  7.1 Concentrators and Distributors 7.2 Slicing and Dicing 7.3
                  Slicing Multistage Networks 7.4 Case Study: Bit Slicing in the
                  Tiny Tera 7.5 Bibliographic Notes 7.6 Exercises Chapter 8
                  Routing Basics 8.1 A Routing Example 8.2 Taxonomy of Routing
                  Algorithms 8.3 The Routing Relation 8.4 Deterministic Routing
                  8.5 Case Study: Dimension-Order Routing in the Cray T3D 8.6
                  Bibliographic Notes 8.7 Exercises Chapter 9 Oblivious Routing
                  9.1 Valiant's Randomized Routing Algorithm 9.2 Minimal
                  Oblivious Routing 9.3 Load-Balanced Oblivious Routing 9.4
                  Analysis of Oblivious Routing 9.5 Case Study: Oblivious
                  Routing in the Avici Terabit Switch Router(TSR) 9.6
                  Bibliographic Notes 9.7 Exercises Chapter 10 Adaptive Routing
                  10.1 Adaptive Routing Basics 10.2 Minimal Adaptive Routing
                  10.3 Fully Adaptive Routing 10.4 Load-Balanced Adaptive
                  Routing 10.5 Search-Based Routing 10.6 Case Study: Adaptive
                  Routing in the Thinking Machines CM-5 10.7 Bibliographic Notes
                  10.8 Exercises Chapter 11 Routing Mechanics 11.1 Table-Based
                  Routing 11.2 Algorithmic Routing 11.3 Case Study: Oblivious
                  Source Routing in the IBM Vulcan Network 11.4 Bibliographic
                  Notes 11.5 Exercises Chapter 12 Flow Control Basics 12.1
                  Resources and Allocation Units 12.2 Bufferless Flow Control
                  12.3 Circuit Switching 12.4 Bibliographic Notes 12.5 Exercises
                  Chapter 13 Buffered Flow Control 13.1 Packet-Buffer Flow
                  Control 13.2 Flit-Buffer Flow Control 13.3 Buffer Management
                  and Backpressure 13.4 Flit-Reservation Flow Control 13.5
                  Bibliographic Notes 13.6 Exercises Chapter 14 Deadlock and
                  Livelock 14.1 Deadlock 14.2 Deadlock Avoidance 14.3 Adaptive
                  Routing 14.4 Deadlock Recovery 14.5 Livelock 14.6 Case Study:
                  Deadlock Avoidance in the Cray T3E 14.7 Bibliographic Notes
                  14.8 Exercises Chapter 15 Quality of Service 15.1 Service
                  Classes and Service Contracts 15.2 Burstiness and Network
                  Delays 15.3 Implementation of Guaranteed Services 15.4
                  Implementation of Best-Effort Services 15.5 Separation of
                  Resources 15.6 Case Study: ATM Service Classes 15.7 Case
                  Study: Virtual Networks in the Avici TSR 15.8 Bibliographic
                  Notes 15.9 Exercises Chapter 16 Router Architecture 16.1 Basic
                  Router Architecture 16.2 Stalls 16.3 Closing the Loop with
                  Credits 16.4 Reallocating a Channel 16.5 Speculation and
                  Lookahead 16.6 Flit and Credit Encoding 16.7 Case Study: The
                  Alpha 21364 Router 16.8 Bibliographic Notes 16.9 Exercises
                  Chapter 17 Router Datapath Components 17.1 Input Buffer
                  Organization 17.2 Switches 17.3 Output Organization 17.4 Case
                  Study: The Datapath of the IBM Colony Router 17.5
                  Bibliographic Notes 17.6 Exercises Chapter 18 Arbitration 18.1
                  Arbitration Timing 18.2 Fairness 18.3 Fixed Priority Arbiter
                  18.4 Variable Priority Iterative Arbiters 18.5 Matrix Arbiter
                  18.6 Queuing Arbiter 18.7 Exercises Chapter 19 Allocation 19.1
                  Representations 19.2 Exact Algorithms 19.3 Separable
                  Allocators 19.4 Wavefront Allocator 19.5 Incremental vs. Batch
                  Allocation 19.6 Multistage Allocation 19.7 Performance of
                  Allocators 19.8 Case Study: The Tiny Tera Allocator 19.9
                  Bibliographic Notes 19.10 Exercises Chapter 20 Network
                  Interfaces 20.1 Processor-Network Interface 20.2 Shared-Memory
                  Interface 20.3 Line-Fabric Interface 20.4 Case Study: The MIT
                  M-Machine Network Interface 20.5 Bibliographic Notes 20.6
                  Exercises Chapter 21 Error Control 411 21.1 Know Thy Enemy:
                  Failure Modes and Fault Models 21.2 The Error Control Process:
                  Detection, Containment, and Recovery 21.3 Link Level Error
                  Control 21.4 Router Error Control 21.5 Network-Level Error
                  Control 21.6 End-to-end Error Control 21.7 Bibliographic Notes
                  21.8 Exercises Chapter 22 Buses 22.1 Bus Basics 22.2 Bus
                  Arbitration 22.3 High Performance Bus Protocol 22.4 From Buses
                  to Networks 22.5 Case Study: The PCI Bus 22.6 Bibliographic
                  Notes 22.7 Exercises Chapter 23 Performance Analysis 23.1
                  Measures of Interconnection Network Performance 23.2 Analysis
                  23.3 Validation 23.4 Case Study: Efficiency and Loss in the
                  BBN Monarch Network 23.5 Bibliographic Notes 23.6 Exercises
                  Chapter 24 Simulation 24.1 Levels of Detail 24.2 Network
                  Workloads 24.3 Simulation Measurements 24.4 Simulator Design
                  24.5 Bibliographic Notes 24.6 Exercises Chapter 25 Simulation
                  Examples 495 25.1 Routing 25.2 Flow Control Performance 25.3
                  Fault Tolerance Appendix A Nomenclature Appendix B Glossary
                  Appendix C Network Simulator}
}
```

{{% /details %}}


### Fault tolerance {#fault-tolerance}


#### Fault Tolerant Computer Architecture (Synthesis Lectures on Computer Architecture) {#fault-tolerant-computer-architecture--synthesis-lectures-on-computer-architecture}

{{% details "Bibtex" %}}

```bibtex
@book{Sorin2009FaultTolerantComputerArchitecture,
  author          = {Sorin, Daniel J.},
  title           = {Fault Tolerant Computer Architecture},
  year            = 2009,
  isbn            = 1598299530,
  publisher       = {Morgan and Claypool Publishers},
  abstract        = {For many years, most computer architects have pursued one
                  primary goal: performance. Architects have translated the
                  ever-increasing abundance of ever-faster transistors provided
                  by Moore's law into remarkable increases in performance.
                  Recently, however, the bounty provided by Moore's law has been
                  accompanied by several challenges that have arisen as devices
                  have become smaller, including a decrease in dependability due
                  to physical faults. In this book, we focus on the
                  dependability challenge and the fault tolerance solutions that
                  architects are developing to overcome it. The two main
                  purposes of this book are to explore the key ideas in
                  fault-tolerant computer architecture and to present the
                  current state-of-the-art - over approximately the past 10
                  years - in academia and industry. Table of Contents:
                  Introduction / Error Detection / Error Recovery / Diagnosis /
                  Self-Repair / The Future}
}
```

{{% /details %}}


#### Single event effects in aerospace {#single-event-effects-in-aerospace}

{{% details "Bibtex" %}}

```bibtex
@book{Petersen2011SingleEventEfefctsInAerospace,
  author          = {Petersen, Edward},
  address         = {Piscataway, N.J.?},
  booktitle       = {Single event effects in aerospace},
  isbn            = 9780470767498,
  publisher       = {IEEE Press},
  keywords        = {Astrionics -- Protection},
  language        = {eng},
  lccn            = 2011002191,
  title           = {Single event effects in aerospace / Edward Petersen.},
}
```

{{% /details %}}


#### Overview of single event effects {#overview-of-single-event-effects}

{{% details "Bibtex" %}}

```bibtex
@book{buchner2015overview,
  title           = {Overview of single event effects},
  author          = {Buchner, S},
  booktitle       = {Proc. 11th Int. School Effects Radiation Embedded Syst.
                  Space Appl.(SERESSA)},
  pages           = {62--69},
  year            = 2015
}
```

{{% /details %}}


#### Draft - Single Event Effects Specification {#draft-single-event-effects-specification}

{{% details "Bibtex" %}}

```bibtex
@online{NASARadEff,
  title           = {Draft - Single Event Effects Specification},
  author          = {{The Radiation Effects and Analysis Group (REAG)}},
  shortauthor     = {REAG},
  organization    = {{National Aeronautics and Space Administration (NASA)}},
  year            = 2017,
  url             = "https://radhome.gsfc.nasa.gov/radhome/papers/seespec.htm",
  note            = {last accessed on 24/01/2021},
}
```

{{% /details %}}


#### Single event effects mitigation techniques report {#single-event-effects-mitigation-techniques-report}

{{% details "Bibtex" %}}

```bibtex
@article{mutuel2016single,
  title           = {Single event effects mitigation techniques report},
  author          = {Mutuel, LH},
  journal         = {Federal Aviation Administration, William J. Hughes
                  Technical Center, Aviation Research Division, Atlantic City
                  International Airport, Final report DOT/FAA/TC-15/62},
  year            = 2016
}
```

{{% /details %}}


#### Circuit Level Design Methods to Mitigate Soft Errors {#circuit-level-design-methods-to-mitigate-soft-errors}

{{% details "Bibtex" %}}

```bibtex
@inproceedings{reis2020CircutLevelDesignmethods,
  author          = {R. {Reis} and C. {Meinhardt} and A. L. {Zimpeck} and L. H.
                  {Brendler} and L. {Moraes}},
  booktitle       = {2020 IEEE Latin-American Test Symposium (LATS)},
  title           = {Circuit Level Design Methods to Mitigate Soft Errors},
  year            = 2020,
  pages           = {1-3},
  doi             = {10.1109/LATS49555.2020.9093683}
}
```

{{% /details %}}


#### SWIFT: software implemented fault tolerance {#swift-software-implemented-fault-tolerance}

{{% details "Bibtex" %}}

```bibtex
@INPROCEEDINGS{reis2005SwitfSoftware,
  author          = {G. A. {Reis} and J. {Chang} and N. {Vachharajani} and R.
                  {Rangan} and D. I. {August}},
  booktitle       = {International Symposium on Code Generation and
                  Optimization},
  title           = {SWIFT: software implemented fault tolerance},
  year            = 2005,
  pages           = {243-254},
  doi             = {10.1109/CGO.2005.34}
}
```

{{% /details %}}


#### Applying Compiler-Automated Software Fault Tolerance to Multiple Processor Platforms {#applying-compiler-automated-software-fault-tolerance-to-multiple-processor-platforms}

{{% details "Bibtex" %}}

```bibtex
@article{james2019applying,
  title           = {Applying Compiler-Automated Software Fault Tolerance to
                  Multiple Processor Platforms},
  author          = {James, Benjamin and Quinn, Heather and Wirthlin, Michael
                  and Goeders, Jeffrey},
  journal         = {IEEE Transactions on Nuclear Science},
  volume          = 67,
  number          = 1,
  pages           = {321--327},
  year            = 2019,
  publisher       = {IEEE}
}
```

{{% /details %}}


#### CDFEDT: Comparison of Data Flow Error Detection Techniques in Embedded Systems: An Empirical Study {#cdfedt-comparison-of-data-flow-error-detection-techniques-in-embedded-systems-an-empirical-study}

{{% details "Bibtex" %}}

```bibtex
@inproceedings{thati2018ComparisonOfDataFlowError,
  author          = {Thati, Venu Babu and Vankeirsbilck, Jens and Penneman,
                  Niels and Pissoort, Davy and Boydens, Jeroen},
  title           = {CDFEDT: Comparison of Data Flow Error Detection Techniques
                  in Embedded Systems: An Empirical Study},
  year            = 2018,
  isbn            = 9781450364485,
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  url             = {https://doi.org/10.1145/3230833.3230854},
  doi             = {10.1145/3230833.3230854},
  abstract        = {Embedded systems used in harsh environments are susceptible
                  to bit-flips, which can cause data flow errors. In order to
                  increase the reliability of embedded systems, numerous data
                  flow error detection techniques have already been developed.
                  It is, however, difficult to identify the best technique to
                  apply, due to differences in the way they are evaluated in
                  current literature.This paper presents an empirical
                  comparative study of seven existing techniques. We measured
                  fault coverage, execution time overhead, and code size
                  overhead. We conclude that soft error detection using software
                  redundancy (SEDSR) and error detection by duplicated
                  instructions (EDDI) have a better trade-off between fault
                  coverage and overheads than software-implemented fault
                  tolerance (SWIFT), critical block duplication (CBD), and
                  overhead reduction (VAR3+). Error detection by diverse data
                  and duplicated instructions (ED4I or EDDDDI) and software
                  approach (SA) had better fault coverage at the expense of
                  execution time and code size usage.},
  booktitle       = {Proceedings of the 13th International Conference on
                  Availability, Reliability and Security},
  articleno       = 23,
  numpages        = 9,
  keywords        = {Fault tolerance, Fault coverage, Bit-flips, Data flow error
                  detection, Comparison},
  location        = {Hamburg, Germany},
  series          = {ARES 2018}
}
```

{{% /details %}}


### Introductory {#introductory}


#### Structured Computer Organization (5th Edition) {#structured-computer-organization--5th-edition}

{{% details "Bibtex" %}}

```bibtex
@book{tanenbaum2005structuredorg,
  author          = {Tanenbaum, Andrew S.},
  title           = {Structured Computer Organization (5th Edition)},
  year            = 2005,
  isbn            = 0131485210,
  publisher       = {Prentice-Hall, Inc.},
  address         = {USA}
}
```

{{% /details %}}


#### Computer Organization and Design, Fifth Edition: The Hardware/Software Interface {#computer-organization-and-design-fifth-edition-the-hardware-software-interface}

{{% details "Bibtex" %}}

```bibtex
@book{patterson2013ComputerOrg,
  author          = {Patterson, David A. and Hennessy, John L.},
  title           = {Computer Organization and Design, Fifth Edition: The
                  Hardware/Software Interface},
  year            = 2013,
  isbn            = 0124077269,
  publisher       = {Morgan Kaufmann Publishers Inc.},
  address         = {San Francisco, CA, USA},
  edition         = {5th},
  abstract        = {The 5th edition of Computer Organization and Design moves
                  forward into the post-PC era with new examples, exercises, and
                  material highlighting the emergence of mobile computing and
                  the cloud. This generational change is emphasized and explored
                  with updated content featuring tablet computers, cloud
                  infrastructure, and the ARM (mobile computing devices) and x86
                  (cloud computing) architectures. Because an understanding of
                  modern hardware is essential to achieving good performance and
                  energy efficiency, this edition adds a new concrete example,
                  "Going Faster," used throughout the text to demonstrate
                  extremely effective optimization techniques. Also new to this
                  edition is discussion of the "Eight Great Ideas" of computer
                  architecture. As with previous editions, a MIPS processor is
                  the core used to present the fundamentals of hardware
                  technologies, assembly language, computer arithmetic,
                  pipelining, memory hierarchies and I/O. Instructors looking
                  for4th Edition teaching materials should e-mail
                  textbook@elsevier.com. Includes new examples, exercises, and
                  material highlighting the emergence of mobile computing and
                  the Cloud. Covers parallelism in depth with examples and
                  content highlighting parallel hardware and software topics
                  Features the Intel Core i7, ARM Cortex-A8 and NVIDIA Fermi GPU
                  as real-world examples throughout the book Adds a new concrete
                  example, "Going Faster," to demonstrate how understanding
                  hardware can inspire software optimizations that improve
                  performance by 200 times. Discusses and highlights the "Eight
                  Great Ideas" of computer architecture: Performance via
                  Parallelism; Performance via Pipelining; Performance via
                  Prediction; Design for Moore's Law; Hierarchy of Memories;
                  Abstraction to Simplify Design; Make the Common Case Fast; and
                  Dependability via Redundancy. Includes a full set of updated
                  and improved exercises.}
}
```

{{% /details %}}


#### Computer Organization and Architecture: Designing for Performance {#computer-organization-and-architecture-designing-for-performance}

{{% details "Bibtex" %}}

```bibtex
@book{stallings2009ComputerOrgPerf,
  author          = {Stallings, William},
  title           = {Computer Organization and Architecture: Designing for
                  Performance},
  year            = 2009,
  isbn            = 9780136073734,
  publisher       = {Prentice Hall Press},
  address         = {USA},
  edition         = {8th},
  abstract        = {KEY BENEFIT: Learn the fundamentals of processor and
                  computer design from the newest edition of this award winning
                  text. KEY TOPICS: Introduction; Computer Evolution and
                  Performance; A Top-Level View of Computer Function and
                  Interconnection; Cache Memory; Internal Memory Technology;
                  External Memory; I/O; Operating System Support; Computer
                  Arithmetic; Instruction Sets: Characteristics and Functions;
                  Instruction Sets: Addressing Modes and Formats; CPU Structure
                  and Function; RISCs; Instruction-Level Parallelism and
                  Superscalar Processors; Control Unit Operation;
                  Microprogrammed Control; Parallel Processing; Multicore
                  Architecture. Online Chapters: Number Systems; Digital Logic;
                  Assembly Language, Assemblers, and Compilers; The IA-64
                  Architecture. MARKET: Ideal for professionals in computer
                  science, computer engineering, and electrical engineering.}
}
```

{{% /details %}}


### RISC-V {#risc-v}


#### The RISC-V Instruction Set Manual Volume II: Privileged Architecture Version v.20190608 {#the-risc-v-instruction-set-manual-volume-ii-privileged-architecture-version-v-dot-20190608}

{{% details "Bibtex" %}}

```bibtex
@techreport{riscv2019PrivilegeArchitecture,
    Author = {Waterman, Andrew and Lee, Yunsup and Avizienis, Rimas and Patterson, David A. and Asanović, Krste},
    Title = {The RISC-V Instruction Set Manual Volume II: Privileged Architecture Ratified Version 1.11},
    Institution = {EECS Department, University of California, Berkeley},
    Year = {2019},
    Month = {Jun},
    URL = {https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf},
    Number = {v.20190608}
}
```

{{% /details %}}


#### The Case for RISC-V in Space {#the-case-for-risc-v-in-space}

{{% details "Bibtex" %}}

```bibtex
@inproceedings{ottavi2019TheCaseForRiscvInSpace,
  author          = "Di Mascio, Stefano and Menicucci, Alessandra and Furano,
                  Gianluca and Monteleone, Claudio and Ottavi, Marco",
  editor          = "Saponara, Sergio and De Gloria, Alessandro",
  title           = "The Case for RISC-V in Space",
  booktitle       = "Applications in Electronics Pervading Industry, Environment
                  and Society",
  year            = 2019,
  publisher       = "Springer International Publishing",
  address         = "Cham",
  pages           = "319--325",
  abstract        = "This paper presentsDi Mascio, Stefano preliminary position
                  on theMenicucci, Alessandra use of the novel, free and open
                  RISC-V Instruction Set Architecture (ISA) for on-boardFurano,
                  Gianluca electronics in space. The modular nature of this ISA,
                  the availability of a rich software ecosystem, a rapidly
                  growing communityMonteleone, Claudio and a pool of open-source
                  IP cores will allow Space Industry to spin-in developments
                  from terrestrial fields (in terms of security, artificial
                  intelligence, support forOttavi, Marco operating systems,
                  hardware acceleration etc.) while focusing its efforts mainly
                  on aspects related to the specific needs of on-board
                  electronics for space applications (e.g. fault tolerance,
                  observability, error signaling, etc.). This will improve reuse
                  and avoid the necessity of developments from scratch when not
                  strategically needed, eventually increasing productivity and
                  reducing costs. The use of an open, non proprietary ISA will
                  allow ad-hoc design of microarchitecture-level soft error
                  countermeasures that can greatly increase the robustness of
                  Application Specific Standard Products (ASSP) and FPGA
                  implementations.",
  isbn            = "978-3-030-11973-7"
}
```

{{% /details %}}


#### The RISC-V Reader: An Open Architecture Atlas {#the-risc-v-reader-an-open-architecture-atlas}

{{% details "Bibtex" %}}

```bibtex
@book{patterson2017RiscvAtlas,
  author          = {Patterson, David and Waterman, Andrew},
  title           = {The RISC-V Reader: An Open Architecture Atlas},
  year            = 2017,
  isbn            = 0999249118,
  publisher       = {Strawberry Canyon},
  edition         = {1st},
  abstract        = {The RISC-V Reader is a concise introduction and reference
                  for embedded systems programmers, students, and the curious to
                  a modern, popular, open architecture. RISC-V spans from the
                  cheapest 32-bit embedded microcontroller to the fastest 64-bit
                  cloud computer. The text shows how RISC-V followed the good
                  ideas of past architectures while avoiding their mistake.
                  Highlights include: Introduces the RISC-V instruction set in
                  only 100 pages, including 75 figures An Instruction Translator
                  Guide to help translate assembly language programs from ARM-32
                  and x86-32 instruction sets to RISC-V 2-page RISC-V Reference
                  Card that summarizes all instructions 50-page Instruction
                  Glossary that defines every instruction in detail 75
                  spotlights of good architecture design using margin icons 50
                  sidebars with interesting commentary and RISC-V history 25
                  quotes to pass along wisdom of noted scientists and engineers
                  Ten chapters introduce each component of the modular RISC-V
                  instruction set--often contrasting code compiled from C to
                  RISC-V versus the older ARM, Intel, and MIPS
                  architectures--but readers can start programming after Chapter
                  2. Praise for The RISC-V Reader: This timely book concisely
                  describes the simple, free and open RISC-V ISA that is
                  experiencing rapid uptake in many different computing sectors.
                  Krste Asanovic, University of California, Berkeley, one of the
                  four architects of RISC-V I like RISC-V and this book as they
                  are elegantbrief, to the point, and complete. C. Gordon Bell,
                  a computer architecture pioneer This handy little book
                  effortlessly summarizes all the essential elements of the
                  RISC-V Instruction Set Architecture, a perfect reference guide
                  for students and practitioners alike. Professor Randy Katz,
                  University of California, Berkeley, one of the inventors of
                  RAID storage systems This clearly-written book offers a good
                  introduction to RISC-V, augmented with insightful comments on
                  its evolutionary history and comparisons with other familiar
                  architectures. John Mashey, one of the designers of the MIPS
                  architecture This book tells what RISC-V can do and why its
                  designers chose to endow it with those abilities. Ivan
                  Sutherland, the father of computer graphics RISC-V will change
                  the world, and this book will help you become part of that
                  change. Professor Michael B. Taylor, University of Washington
                  This book will be an invaluable reference for anyone working
                  with the RISC-V ISA. Megan Wachs, PhD, SiFive Engineer}
}
```

{{% /details %}}


#### The RISC-V Instruction Set Manual (2014) {#the-risc-v-instruction-set-manual--2014}

{{% details "Bibtex" %}}

```bibtex
@misc{Waterman14therisc-v,
  author          = {Andrew Waterman and Yunsup Lee and David A. Patterson and
                  Krste Asanovic and Volume I User-level Isa and Andrew Waterman
                  and Yunsup Lee and David Patterson},
  title           = {The RISC-V Instruction Set Manual},
  year            = 2014
}
```

{{% /details %}}


#### Computer Organization and Design RISC-V Edition: The Hardware Software Interface {#computer-organization-and-design-risc-v-edition-the-hardware-software-interface}

{{% details "Bibtex" %}}

```bibtex
@book{patterson2017ComputerOrgRiscvEdition,
  author          = {Patterson, David A. and Hennessy, John L.},
  title           = {Computer Organization and Design RISC-V Edition: The
                  Hardware Software Interface},
  year            = 2017,
  isbn            = 0128122757,
  publisher       = {Morgan Kaufmann Publishers Inc.},
  address         = {San Francisco, CA, USA},
  edition         = {1st},
  abstract        = {The new RISC-V Edition of Computer Organization and Design
                  features the RISC-V open source instruction set architecture,
                  the first open source architecture designed to be used in
                  modern computing environments such as cloud computing, mobile
                  devices, and other embedded systems. With the post-PC era now
                  upon us, Computer Organization and Design moves forward to
                  explore this generational change with examples, exercises, and
                  material highlighting the emergence of mobile computing and
                  the Cloud. Updated content featuring tablet computers, Cloud
                  infrastructure, and the x86 (cloud computing) and ARM (mobile
                  computing devices) architectures is included. An online
                  companion Web site provides advanced content for further
                  study, appendices, glossary, references, and recommended
                  reading. Features RISC-V, the first such architecture designed
                  to be used in modern computing environments, such as cloud
                  computing, mobile devices, and other embedded systems Includes
                  relevant examples, exercises, and material highlighting the
                  emergence of mobile computing and the cloud}
}
```

{{% /details %}}


## Software Engineering {#software-engineering}


### Embedded systems {#embedded-systems}


#### Modeling C-based embedded system using UML design {#modeling-c-based-embedded-system-using-uml-design}

{{% details "Bibtex" %}}

```bibtex
@inproceedings{wang2009modeling,
  author          = { {Guoping Wang}},
  booktitle       = {2009 International Conference on Mechatronics and
                  Automation},
  title           = {Modeling C-based embedded system using UML design},
  year            = 2009,
  pages           = {2973-2977},
  abstract        = {Unified Modeling Language (UML) 2.0 is emerging in the area
                  of modeling the design of embedded system. The most common
                  implementation for the embedded-system models has been C++. On
                  one hand, the most common programming language for embedded
                  system overall by far is the functional language C. On the
                  other hand, the UML is used almost exclusively for
                  object-oriented systems development. This paper present an
                  approach of applying UML in the functionally-oriented embedded
                  systems design. This approach is illustrated using a stopwatch
                  design example.},
  keywords        = {C++ language;embedded systems;functional languages;Unified
                  Modeling Language;modeling C-based embedded system;UML
                  design;Unified Modeling Language;UML 2.0;C++;programming
                  language;functional language C;object-oriented systems
                  development;functionally-oriented embedded systems
                  design;stopwatch design;Embedded system;Unified modeling
                  language;Object oriented modeling;Computer languages;Embedded
                  computing;Real time systems;Costs;Energy
                  consumption;Mechatronics;Design automation;UML
                  modeling;embedded system
                  design;object-oriented;function-oriented},
  doi             = {10.1109/ICMA.2009.5246023},
  ISSN            = {2152-744X},
  month           = {Aug},
}
```

{{% /details %}}


### Fault tolerant {#fault-tolerant}


#### Basic concepts and taxonomy of dependable and secure computing {#basic-concepts-and-taxonomy-of-dependable-and-secure-computing}

{{% details "Bibtex" %}}

```bibtex
@article{avizienis2004ConceptsOfSecureComputing,
  author          = {A. {Avizienis} and J. -. {Laprie} and B. {Randell} and C.
                  {Landwehr}},
  journal         = {IEEE Transactions on Dependable and Secure Computing},
  title           = {Basic concepts and taxonomy of dependable and secure
                  computing},
  year            = 2004,
  volume          = 1,
  number          = 1,
  pages           = {11-33},
  abstract        = {This paper gives the main definitions relating to
                  dependability, a generic concept including a special case of
                  such attributes as reliability, availability, safety,
                  integrity, maintainability, etc. Security brings in concerns
                  for confidentiality, in addition to availability and
                  integrity. Basic definitions are given first. They are then
                  commented upon, and supplemented by additional definitions,
                  which address the threats to dependability and security
                  (faults, errors, failures), their attributes, and the means
                  for their achievement (fault prevention, fault tolerance,
                  fault removal, fault forecasting). The aim is to explicate a
                  set of general concepts, of relevance across a wide range of
                  situations and, therefore, helping communication and
                  cooperation among a number of scientific and technical
                  communities, including ones that are concentrating on
                  particular types of system, of system failures, or of causes
                  of system failures.},
  keywords        = {fault tolerant computing;data privacy;security of
                  data;system recovery;software reliability;taxonomy;dependable
                  computing;secure computing;system reliability;system
                  availability;system safety;system integrity;system
                  maintainability;fault prevention;fault tolerance;fault
                  removal;fault forecasting;system security;system
                  failures;system vulnerabilities;system
                  attacks;Taxonomy;Availability;Fault
                  tolerance;Safety;Maintenance;Communication system
                  security;Uncertainty;Standardization;Books;Index Terms-
                  Dependability;security;trust;faults;errors;failures;vulnerabilities;attacks;fault
                  tolerance;fault removal;fault forecasting.},
  doi             = {10.1109/TDSC.2004.2},
  ISSN            = {1941-0018},
  month           = {Jan},
}
```

{{% /details %}}


#### System structure for Software Fault Tolerance {#system-structure-for-software-fault-tolerance}

{{% details "Bibtex" %}}

```bibtex
@ARTICLE{RandellSysStructureForSoftwareFaultTolerance,
  author          = {Randell, Brian},
  journal         = {IEEE Transactions on Software Engineering},
  title           = {System structure for software fault tolerance},
  year            = 1975,
  volume          = {SE-1},
  number          = 2,
  pages           = {220-232},
  abstract        = {Presents and discusses the rationale behind a method for
                  structuring complex computing systems by the use of what is
                  termed `recovery blocks,' `conversations,' and `fault-tolerant
                  interfaces.' The aim is to facilitate the provision of
                  dependable error detection and recovery facilities which can
                  cope with errors caused by residual design inadequacies,
                  particularly in the system software, rather than merely the
                  occasional malfunctioning of hardware components.},
  doi             = {10.1109/TSE.1975.6312842},
  ISSN            = {1939-3520},
  month           = {June},
}
```

{{% /details %}}


## Mathematics {#mathematics}


### Binary {#binary}


#### Bit Twiddling Hacks {#bit-twiddling-hacks}

{{% details "Bibtex" %}}

```bibtex
@misc{sean2005BitTwiddlingHacks,
  title           = { Bit Twiddling Hacks },
  url             = {https://graphics.stanford.edu/~seander/bithacks.html},
  journal         = {Bit Twiddling Hacks},
  author          = {Sean Eron Anderson}
}
```

{{% /details %}}


#### Binary number representation {#binary-number-representation}

{{% details "Bibtex" %}}

```bibtex
@misc{binaryNumberRepresentation,
  title           = {Unsigned Binary Integer},
  url             =
                  {https://www.mathcs.emory.edu/~cheung/Courses/255/others/BinNumReps.html},
  journal         = {Binary Number Representations}
}
```

{{% /details %}}


#### What are bitwise shift (bit-shift) operators and how do they work? {#what-are-bitwise-shift--bit-shift--operators-and-how-do-they-work}

{{% details "Bibtex" %}}

```bibtex
@misc{derekpark2008WhatAreBitwiseShift,
  title           = {What are bitwise shift (bit-shift) operators and how do
                  they work?},
  url             = {https://stackoverflow.com/a/141873},
  journal         = {What are bitwise shift (bit-shift) operators and how do
                  they work},
  publisher       = {Stackoverflow},
  author          = {Derek Park},
  year            = 2008,
  month           = {Sep}
}
```

{{% /details %}}


## Database {#database}


### SQL databases v. NoSQL databases {#sql-databases-v-dot-nosql-databases}

{{% details "Bibtex" %}}

```bibtex
@article{stonerbraker2020SQLDatabasesvNoSQLDatabases,
  author          = {Stonebraker, Michael},
  title           = {SQL Databases v. NoSQL Databases},
  year            = 2010,
  issue_date      = {April 2010},
  publisher       = {Association for Computing Machinery},
  address         = {New York, NY, USA},
  volume          = 53,
  number          = 4,
  issn            = {0001-0782},
  url             = {https://doi.org/10.1145/1721654.1721659},
  doi             = {10.1145/1721654.1721659},
  abstract        = {The Communications Web site, http://cacm.acm.org, features
                  more than a dozen bloggers in the BLOG@CACM community. In each
                  issue of Communications, we'll publish excerpts from selected
                  posts.twitterFollow us on Twitter at
                  http://twitter.com/blogCACMMichael Stonebraker considers
                  several performance arguments in favor of NoSQL
                  databases---and finds them insufficient.},
  journal         = {Commun. ACM},
  month           = apr,
  pages           = {10–11},
  numpages        = 2
}
```

{{% /details %}}


## Algorithms {#algorithms}


### Lock-Free Red-Black Trees Using CAS {#lock-free-red-black-trees-using-cas}

{{% details "Bibtex" %}}

```bibtex
@inproceedings{Kim2011LockFreeRT,
  title={Lock-Free Red-Black Trees Using CAS},
  author={Jong Ho Kim and Helen Cameron and Peter C. J. Graham},
  year={2011}
}
```

{{% /details %}}


### Parallel algorithms for red–black trees {#parallel-algorithms-for-red-black-trees}

{{% details "Bibtex" %}}

```bibtex
@article{park2001ParallelAlgorithms,
  title           = {Parallel algorithms for red–black trees},
  journal         = {Theoretical Computer Science},
  volume          = 262,
  number          = 1,
  pages           = {415-435},
  year            = 2001,
  issn            = {0304-3975},
  doi             = {https://doi.org/10.1016/S0304-3975(00)00287-5},
  url             = {https://www.sciencedirect.com/science/article/pii/S0304397500002875},
  author          = {Heejin Park and Kunsoo Park},
  keywords        = {Red–black trees, Balanced search trees, Parallel
                  algorithms, Dictionary operations},
  abstract        = {We present parallel algorithms for the following four
                  operations on red–black trees: construction, search,
                  insertion, and deletion. Our parallel algorithm for
                  constructing a red–black tree from a sorted list of n items
                  runs in O(1) time with n processors on the CRCW PRAM and runs
                  in O(loglogn) time with n/loglogn processors on the EREW PRAM.
                  Our construction algorithm does not require the assumptions
                  that previous construction algorithms used. Each of our
                  parallel algorithms for search, insertion, and deletion in
                  red–black trees runs in O(logn+logk) time with k processors on
                  the EREW PRAM, where k is the number of unsorted items to
                  search for, insert, or delete and n is the number of nodes in
                  a red–black tree.}
}

```

{{% /details %}}


### Introduction to algorithms {#introduction-to-algorithms}

{{% details "Bibtex" %}}

```bibtex
@book{introToAlgorithms2009,
  author          = {Cormen, Thomas H. and Leiserson, Charles E. and Rivest,
                  Ronald L. and Stein, Clifford},
  title           = {Introduction to Algorithms, Third Edition},
  year            = 2009,
  isbn            = 0262033844,
  publisher       = {The MIT Press},
  edition         = {3rd},
  abstract        = {If you had to buy just one text on algorithms, Introduction
                  to Algorithms is a magnificent choice. The book begins by
                  considering the mathematical foundations of the analysis of
                  algorithms and maintains this mathematical rigor throughout
                  the work. The tools developed in these opening sections are
                  then applied to sorting, data structures, graphs, and a
                  variety of selected algorithms including computational
                  geometry, string algorithms, parallel models of computation,
                  fast Fourier transforms (FFTs), and more. This book's strength
                  lies in its encyclopedic range, clear exposition, and powerful
                  analysis. Pseudo-code explanation of the algorithms coupled
                  with proof of their accuracy makes this book is a great
                  resource on the basic tools used to analyze the performance of
                  algorithms.}
}
```

{{% /details %}}


### Toward a Unique Representation for AVL and Red-Black Trees {#toward-a-unique-representation-for-avl-and-red-black-trees}

{{% details "Bibtex" %}}

```bibtex
@article{BOUNIF2019,
  title           = {{Toward a Unique Representation for AVL and Red-Black
                  Trees}},
  journal         = {{Computaci\~A\textthreesuperiorn y Sistemas}},
  author          = {Bounif, Lynda AND Zegour, Djamel Eddine},
  ISSN            = {1405-5546},
  language        = {en},
  URL             = {http://www.scielo.org.mx/scielo.php?script=sci_arttext&pid=S1405-55462019000200435&nrm=iso},
  volume          = 23,
  year            = 2019,
  month           = 06,
  pages           = {435 - 450},
  publisher       = {scielomx},
  crossref        = {10.13053/cys-23-2-2840},
}
```

{{% /details %}}


### Problemas Dinâmicos de Coleta e Entrega Com Janelas de Tempo {#problemas-dinâmicos-de-coleta-e-entrega-com-janelas-de-tempo}

{{% details "Bibtex" %}}

```bibtex
@inproceedings{problemasDinamicosDeColetaEEntregaComJanelasDeTempo,
  author          = {Eccel, Renan and Carlson, Rodrigo},
  year            = 2019,
  month           = 11,
  title           = {PROBLEMAS DINÂMICOS DE COLETA E ENTREGA COM JANELAS DE
                  TEMPO: ANÁLISE DAS INSTÂNCIAS DE BENCHMARK}
}
```

{{% /details %}}


### Concurrent, lock-free insertion in red-black trees {#concurrent-lock-free-insertion-in-red-black-trees}

{{% details "Bibtex" %}}

```bibtex
@article{ma2004concurrent,
  title           = {Concurrent, lock-free insertion in red-black trees},
  author          = {Ma, Jianwen},
  year            = 2004
}
```

{{% /details %}}
